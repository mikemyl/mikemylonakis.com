---
title:  "Go cheatsheet"
permalink: /notebook/go/
excerpt: "Go (aka Golang) cheatsheet"
toc: true
toc_sticky: true
last_modified_at: 2020-10-07T18:00:00-04:00
---

These notes are heavily influenced by Bill Kennedy's course [Ultimate go Programming](https://www.google.com/url?sa=t&rct=j&q=&esrc=s&source=web&cd=&cad=rja&uact=8&ved=2ahUKEwiBoLy2krjzAhVB2qQKHQpZDpAQFnoECA0QAQ&url=https%3A%2F%2Fwww.oreilly.com%2Flibrary%2Fview%2Fultimate-go-programming%2F9780135261651%2F&usg=AOvVaw0fpZnv0p5hst60_FUPzdYI)

## Variables

### Declaration

```go
// Zero value initialization
var a string                
var b int                   // size of int depends on the architecture
var c float64
var d bool  

// Short variable declaration - declare and initialize
aa := 10
bb := "hello"
cc := 3.14159
dd := true
```

### Strings

Strings are 2 words, and the word size depends on the architecture. A word in 32-bit systems is 4 bytes, while a 
word on 64-bit systems is 8 bytes. So string variables are 8 bytes on 32-bit machines, and 16 bytes on 64-bit machines.

{% include figure image_path="/assets/images/figures/go/strings.drawio.svg" alt="Strings mental model" %}

#### Ranging Over a String

When ranging over a string, we range through its codepoints. Codepoints are between 1-4 bytes, and represent 1 UTF-8 character.

```go
// Declare a string with both chinese and english characters.
	s := "世界 means world"

	// UTFMax is 4 -- up to 4 bytes per encoded rune.
	var buf [utf8.UTFMax]byte

	// Iterate over the string.
	for i, r := range s {

		// Capture the number of bytes for this rune.
		rl := utf8.RuneLen(r)

		// Calculate the slice offset for the bytes associated
		// with this rune.
		si := i + rl

		// Copy of rune from the string to our buffer.
		copy(buf[:], s[i:si])

		// Display the details.
		fmt.Printf("%2d: %q; codepoint: %#6x; encoded bytes: %#v\n", i, r, r, buf[:rl])
	}
```


### Structs

#### Padding

```go
//declaration. Name type
type example struct {
	flag    bool
	counter int16
	pi      float32
}
```

How much memory does struct `example` consume? 7 bytes, right? Not quite! The main memory is word - aligned, which means
that addresses need to be a multiple of the word size. Therefore, that struct needs 8 bytes, 1 of which is just padding.

{% include figure image_path="/assets/images/figures/go/structs.drawio.svg" alt="Struct memory layout" %}


Every value needs to be properly aligned in memory, based on its size:
- 2byte values should be put on "multiple of 2 addresses". That is xxxxxxxx0, xxxxxxxx2, xxxxxxxx4 ....
- 4byte values should be put on "multiple of 2 addresses". That is xxxxxxxx0, xxxxxxxx4, xxxxxxxx8 ....

Ordering fields from largest to smallest helps reduce the padding.

#### Struct Types

```go
//declaration. Name type
type example struct {
	flag    bool
	counter int16
	pi      float32
}

type example2 struct {
	flag    bool
	counter int16
	pi      float32
}

//construction
e := example{
	flag:     true,
	counter:  10,
	pi:       3.141592,
}

//anonymous type and literal construction - struct. Literal type
e1 := struct {
	flag    bool
	counter int16
	pi      float32
}{}
```

#### Conversion

Go doesn't have casting (unless we use the unsafe package). It has type conversion.

```go
aa := 10
aaa := int32(aa)            // completely different memory location than aa. Has the cost of allocating new memory, but it's safer. 
```

```go
//Implicit conversion for name types - won't compile
var a example
var b example2
a = b               // won't work
a = example(b)      // explicit conversion, will work
a = e1              // implicit conversion works, for literal types 
```

Implicit conversion is not allowed in go, for name types! We can't assign a var of type `example` to another, identical struct
even if the 2 struct types are pretty much the same - we would have to do explicit conversion. We can, however, assign a variable of the literal type `e1` to a
 variable of type `example`. 

### Pointers

Everything in Go is pass by value (addresses are also data, and they 're passed by value).

```go
// value semantics, the value of inc is copied
func increment(inc int) int {
  inc++ 
  return inc
}

// pointer semantics, the address of inc is copied
func increment(int *int) {
  *inc++
}

```

Value Semantics: Isolation, Immutability (a function operates on its own copy of data). But there is the cost of copying the data.
Pointer Semantics: Efficiency, data sharing. But there are side effects, when modifying shared state. 

#### Escape Analysis

Go figures out which variables need to be put on the heap (because we 're sharing them up the call stack), by performing
a static code analysis. Stacks should be our first priority, cause they're pre-allocated, faster, self-cleaning. 

```go

type data struct {
  foo int
  bar string
}

func createData() *data {
  d := data{
    foo: 1,
    bar: "norf",
  } 
  
  //escapes the stack (heap allocation)
  return &d
}

```

**On return statements:** Prefer `return &d` over `return d (where d is declared as d := &data{...})` as the former
makes it clear that there is a heap allocation (we 're sharing data up the call stack). If we use the latter, we need
to track where the data var is declared, notice that it's a pointer type and then conclude that a heap allocation
is taking place.
{: .notice--warning}

**On Stacks:**
* Operating System Threads: Stacks are usually 1 MB.
* Goroutines: Stacks are 2 KB.
* When a goroutine runs out of stack space, Go allocates a 25% bigger stack, and copies the stack frames from the older stack. 
{: .notice--info}
  
#### Garbage Collection

Tri color, mark and sweep concurrent collector. The are still some stop-the-world pauses, but they're being kept at their
bare minimum. It's not compacting (i.e. memory on the heap is not moved around, like jvm's garbage collector for instance).

The pacing algorithm makes sure that the stop-the-world pauses don't last longer than 100 μs, per run. It can take up to
25% of the available CPU capacity.


### Constants

```go
// Constants of a kind - can be implicitly converted by the compiler
const ki = 5345     // kind: integer
const kf = 4.7366  // kind: floating-point

// Constants of a type 
const ti int = 5345        // type: int 
const tf float64 = 4.7366  // type: float64

// Kind Promotion - ret is of type float64
var ret = 4 * 1.824  // KindFloat(4) * KindFloat(1.824)

```

Constants in go have 256 bits of precision.

Practical example of constant usage, in the time package:

```go
type Duration int64

const (
       Nanosecond duration = 1
       Microsecond         = 1000 * Nanosecond
       Milisecond          = 1000 * Microsecond
       Second              = 1000 * Milisecond
       // ...
)
```

#### iota

```go
const (
       A1 = iota // 0
       B1        // 1
       C1        // 2
)
```

### Arrays

```go
var fruits [3]string
fruits[0] = "Apple"
fruits[1] = "Banana"
fruits[2] = "Pear"

// declare and initialize
var fruits := [3]string{"Apple", "Banana", "Pear"}
```

Cache lines are usually 64 bytes.

Predictable access patterns to memory.

TLB misses (TLB lookup translates virtual to physical memory addresses)

Memory Pages usually 4k or 8k 

### Slices

Slices are 3 word data structures (24 bytes on 64bit architectures):
1. A pointer to the backing array
2. Its length
3. Its capacity (if that's not defined on the make call, it's the same as the length)

```go
fruits := make([]string, 3) 
fruits[0] = "Apple"
fruits[1] = "Banana"
fruits[2] = "Pear"

var data []string   // initialized to its zero value (nil,0,0)
data := []string{}  // empty slice ( != to the above line, which is the zero value for slice ). It points to the empty struct{}, which is unique in the go runtime

length := len(data)
capacity := cap(data)
```

We can also create a slice from any given array by applying that syntax:

```go
arr := []string{"A", "B", "C"}
sl := arr[:]   // Creates a slice backed by the 'arr' backing array, with length == capacity == 3

```

#### Appending

```go
fruits = append(fruits, "kiwi")                     // value semantic API. Operates on a copy of the original slice, then returns it
fmt.Printlf("%s - %s", len(fruits), cap(fruits))    // prints (4, 6). When length == capacity, append doubles the backing array to add a new element 
```

{% include figure image_path="/assets/images/figures/go/slices.drawio.svg" alt="Append" %}


```go
fruits := make([]string, 0, 4) // if we know the number of elements that we re going to add beforehand, we can pre
                               // allocate the backing array by setting lenth to 0 and capacity to the number of elements 
fruits := make([]string, 4)    // or even better, we can pre allocate, init to 0 value, and set elements by indexing: data[0]=...
```

When length == capacity, appends creates a new backing array. References to elements pointing to the old backing array,
are memory leaks and can cause nasty bugs.
{: .notice--warning}



#### Slicing

```go
	data := []string{"a", "b", "c", "d", "e"}
	
	fmt.Println(data[2:2+2])              // Prints [c d]. Note that it's [2, 4) - i.e. not including the 4th element. 
	fmt.Println(len(data[2:2+2]))         // Prints 2.
	fmt.Println(cap(data[2:2+2]))         // Prints 3. The new slice can still access "d" and "e". Append will not allocate a new slice in this case.
	
	data := data[2:4:4]                   // Also sets the capacity of the new slice. This can be helpful, as any future additions
	                                      // to the new slice are not visible to the original slice, as append will return a new slice
	                               
  data2 := make([]string, len(data))    // Make a new slice, with length and capacity == len(data), cap(data)
  copy(data2, data)                     // And use the built-in copy, to copy the contents
```

#### Ranging over a slice

##### Value Semantics

```go

// We re iterating over a copy of the items slice - we don't see the original slice modification, in our iteration
items := []string{"foo", "bar", "norf", "qux", "foobar"}
for i, v := range items {
        items[1] = "baz"
        if i == 1 {
                 fmt.printf(v) // prints bar - value semantics means we 're iterating over the a copy and not the original items
        }
        fmt.Printf("v[%s]", item)
}

```


##### Pointer Semantics

```go

// We re iterating over the original slice
items := []string{"foo", "bar", "norf", "qux", "foobar"}
for i := range items {
        items[1] = "baz"
        if i == 1 {
                 fmt.printf(items[1]) // prints baz - pointer semantics means we 're iterating over the original slice
        }
        fmt.Printf("v[%s]", item)
}

```

### Maps

```go
ids := make(map[string]int)
id["Mike"] = 1
id["John"] = 2

// literal construction
ids := map[string]int{
        "Mike" : 1,
        "John" : 2,
       }

id := id["Mike"]       // 1
id, ok := id["George"] // 0 (that's always the value's zero value), false
```



* We can't change the hashing algorithm
* In order for a map to be usable, we need to call `make`. It's not usable in its zero value state (i.e. with `var`)
  (in contrast to slices, for example)
{ :.notice--info}

#### Ranging over a map

```go
for key, value := range ids {
  fmt.Println(key, value)
}
```

```go
for key := range ids {
  fmt.Println(key, id["key"])
}
```

The order is random.
{ :.notice--info}

## Methods

Methods are functions with receivers. This way we can have data with behavior.

```go

type person struct {
  name      string
  address   string
}


// Value received
func (p person) alert() {
  fmt.Println("%s : %s", p.name, p.address)
}

// Pointer receiver
func (p *person) changeAddress(address string) {
  p.address = address
}

mike := person{"Mike", "London"}


mike.alert()                    // equivalent to person.alert(mike) - methods are just syntactic sugar

mike.changeAddress("Athens")    // equivalent to (*person).changeAdress(&mike, "Athens")

}

```

### Value vs Pointer Semantic

When in doubt:

|     Type          |  Semantic                                      |
|-------------------|------------------------------------------------|
| Built in Types    |  Value                                         |
| Reference Types   |  Value   (except when decoding, unmarshalling) |
| User Defined Types|  Pointer (*)                                   |

* For struct types, it's worth asking if mutating the data is still the same data (i.e. modifying a person's address) - pointer semantics - or
  a new piece of data (i.e. modifying a point in time or a string) - value semantics.
* If we are using someone else's struct type, we should follow the semantic from the factory functions that create those struct values.   
{ :.notice--info}

## Interfaces

Interface types are not "real" types. They only define a set of methods (behavior). They're reference types, 2 words in size:
* The 1st word is a pointer to the iTable (iTable : Matrix of function pointers - similar to the vTable in C++).
* The 2nd word is a pointer to the concrete data that satisfies that interface.

```go
type Reader interface {
    read(b []byte) (int, error)
}

type File struct {..}
type Pipe struct {..}

func (f File) read(b []byte) (int, error) {..}
func (p Pipe) read(b []byte) (int, error) {..}

func retrieve(r reader) error {...}

var f File
var p Pipe

retrieve(f)                 // We can also call retrieve(&f). This is usefull on some ocassions (decoding, unmarshalling)
retrieve(p)                 // We can also call retrive(&p). This is usefull on some ocassions (decoding, unmarshalling)
```

{% include figure image_path="/assets/images/figures/go/interfaces.drawio.svg" alt="Append" %}

As we can see in the above figure, decoupling has that extra lookup cost.
{ :.notice--info}

### Method Sets

```go

type Dev struct {..}
func (d *Dev) read{..}      // Dev implements Reader using pointer semantics
var d dev

retrive(d)                  // can't call retrieve using a value of type Dev. Needs to be a pointer of type Dev!            
```

| Interface Implementation  |  Receiver Type                                                                                                                           |
|---------------------------|------------------------------------------------------------------------------------------------------------------------------------------|
| Value Receiver   (T)      |  Value, and Pointer (i.e. can call(d), call(&d). Useful when decoding, unmarshalling)                                                    |
| Pointer Receiver (*T)     |  Pointer only (i.e. can only call(&d). Copying the value that a pointer points to is generally not safe, compilers forbids this use case)|
